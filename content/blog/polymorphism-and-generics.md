+++
title = "多态系统与实现机制"
description = "An analysis of polymorphism from the perspective of programming methods and binding time, covering closures, generic functions, monomorphization, and dynamic dispatch."

date = 2025-12-24
updated = 2025-12-24

[taxonomies]
authors = ["nekrozis"]
categories = ["PL"]

tags = [
  "programming-methods",
  "program-construction",

  "polymorphism",
  "generic-programming",
  "binding-time",

  "static-dispatch",
  "dynamic-dispatch",

  "closures",
  "generic-functions",
  "monomorphization",
  "virtual-tables",

  "Scheme",
  "CLOS",
  "Rust",
  "C++"
]

[extra]
math = false
mermaid = false
+++

# 多态系统与实现机制

## 多态 —— 操作与数据的解耦

在构建复杂软件系统时，我们总会碰到一个根本性的设计矛盾：我们希望写出能在多种数据类型上通用的逻辑，但每种类型又自带不同的行为。举个例子，我们可能想要一个统一的 `add(a, b)` 操作，既能处理整数相加，也能处理浮点数累加、矩阵加法，甚至用户自定义类型的聚合逻辑。但整数加法和矩阵加法的实现方式完全不同，这种差异不仅是语义上的，也是类型系统在不同结构上施加操作约束的直接体现。

如果我们只想着“起个统一名字”，那可能只是语法上的小把戏。但真正的挑战在于：希望高层逻辑根本不必理会底层类型的具体实现。比如看这个泛型函数：

```cpp
template <typename T>
T sum_all(const std::vector<T>& xs) {
    T result{} ;
    for (auto& x: xs) result = add(result, x);
    return result;
}
```

这里的 `sum_all` 只是定义了一个累加的组合模式，它并不关心 `T` 是整数、浮点数、复数，还是其他可加类型。它唯一的前提是存在一个能完成 `add(result, x)` 的操作，把两个 `T` 类型的值组合起来。这正体现了 参数多态（parametric polymorphism） 的核心思想：把算法和类型分离，让同一个算法能在不同类型上复用，而无需了解类型的内部实现。

这个例子也揭示了泛型编程的基本目标：让算法专注于组合逻辑，而不是因为类型不同而重复实现相同逻辑。当我们用泛型写 `sum_all` 时，编译器会根据不同的 T 实例化不同版本，这就是所谓的 单态化（monomorphization）。单态化会在编译期展开泛型函数，生成多个具体函数版本，从而在运行时不需要查表或动态选择实现。虽然这可能会让代码体积增大，但它实现了所谓的 零成本抽象（zero-cost abstraction），既保证类型安全，又保持高性能。

从更广的角度看，构建一个可复用、类型无关的基础操作（如 `add`）其实是在做 语义提炼：把某种行为从具体类型中抽象出来，让不同实例共享同一逻辑，同时让高层组合算法无需关心类型细节。这不仅是泛型编程的核心，也是函数式编程、面向对象编程以及多方法系统共同追求的目标。

当然，不同语言在决定“何时调用哪个实现”上各有策略。这引出了两种对立的架构选择：

- 早绑定（Early Binding / 静态派发 Static Dispatch）：在编译期就确定调用目标
- 迟绑定（Late Binding / 动态派发 Dynamic Dispatch）：在运行时根据实际类型选择实现

这种选择不仅影响编译器生成的代码结构，也深刻左右运行时性能、可扩展性和泛型组合能力。而这些，正是我们接下来要深入探讨的核心问题。

## Scheme 中的闭包模拟对象

理解了泛型和绑定时间的概念之后，我们不妨看看动态语言是如何实现类似的抽象和多态的。在静态语言中，编译期就能确定许多操作，但在像 Scheme 这样的 Lisp 方言中，语言本身提供了强大的函数抽象能力和闭包机制，使我们可以在运行时构建灵活的对象模型。通过闭包，我们不仅可以封装状态，还能实现消息传递式的方法选择，从而在动态环境中模拟对象行为，同时保留抽象屏障和多态的思想。

在很多 Lisp 方言里，闭包（closure）不仅是一种控制结构的实现手段，还能用来模拟带封装性和方法分发能力的对象。闭包本质上是函数与其环境（变量绑定）组合而成的第一类对象，它可以在创建时捕获周围环境中的变量，并在后续调用中引用这些绑定。

利用闭包，我们可以构建具有内部状态和方法选择行为的“对象”。下面是一个经典的 Scheme 闭包实现的 `point` 对象示例：

```scheme
(define (point x y)
  (letrec ((getx (lambda () x))
           (gety (lambda () y))
           (add (lambda (p) (point (+ x ((p 'getx))) (+ y ((p 'gety))))))
           (type-of (lambda () 'point)))
    (lambda (message)
      (cond 
        ((eq? message 'getx) getx)
        ((eq? message 'gety) gety)
        ((eq? message 'add) add)
        ((eq? message 'type-of) type-of)
        (else (error "Message not understood"))))))
```

在这个例子中：

内部函数 `getx`、`gety`、`add` 和 `type-of` 捕获了局部变量 `x` 与 `y` 的状态。

最终返回的匿名函数（dispatch 函数）会根据传入消息选择并返回对应方法。换句话说，它通过“消息”驱动闭包，返回相应的函数实现。

创建一个点对象：

```scheme
(define p (point 3 4))
```

然后调用：

```scheme
((p 'getx)) ; -> 3
```

这会返回 `getx` 闭包，并通过第二次调用得到结果。这种方式在行为上等同于传统 OOP 中的 `p.getX()`，只是这里用的是 消息传递（message passing）。

### 消息传递与抽象屏障

闭包 + 消息传递模式提供了一个基础的抽象屏障：

- 私有状态：`x` 和 `y` 对闭包外部不可见。
- 方法作为值：每个方法都是第一类 Lambda 函数，可返回、组合或存储。
- 消息驱动接口：使用者仅通过消息名称与对象交互，无需关心内部实现。

这里还体现了重要的绑定时间特性：

> 方法选择发生在运行时（迟绑定）
> 当 `p` 接收到消息时，`dispatch` 函数在运行时执行 `cond` 分支，根据消息符号决定返回哪个方法闭包。这意味着调用行为不是在定义闭包时就固定的，而是在每次运行时动态选择实现。这种迟绑定让对象实现更灵活，但每次调用都需进行消息解析和查找。

## CLOS：将行为提升为一等概念
    
在上一节中，我们观察了 Scheme 如何利用闭包和消息传递构建动态对象模型，其中方法选择在运行时根据消息名称动态决定（迟绑定 / 运行时分派）。这种延迟决策使得抽象灵活、可扩展，但仅是动态对象模拟的基本形式。在更复杂的系统中，我们希望将这种动态性提升到语言级，让操作本身成为可组合的抽象，而不仅仅依附于某个对象或类。

Common Lisp Object System（CLOS）正是这样一种通用动态多态机制。它是 ANSI Common Lisp 标准的一部分，提供了一个强大的动态对象系统，其中泛型函数（generic function）和多方法（multi-method）是核心构造。CLOS 支持多分派（multiple dispatch） ——在运行时根据所有参数类型组合选择最合适的方法实现。

在 CLOS 中：

- 方法不属于某个类，而是归属于一个 泛型函数。
- 泛型函数是一个可调用的对象，它携带了多个 `defmethod` 注册的方法集合。
- 每个方法都可以针对不同的参数类型组合进行特化（specialization）。
- 在调用时，系统在运行时对所有参数的实际类型进行匹配，从已注册的方法中选择并组合出一个“有效方法”来执行。

这种设计使得行为调度不再局限于单个对象的内部消息处理，而是在全参数层面根据具体类型做通用动态决策。

### 泛型函数：行为的抽象容器

CLOS 中的泛型函数由 defgeneric 定义，类似普通函数，但本身不包含具体实现。通过 defmethod 定义的方法与泛型函数关联，形成一组可用于不同类型组合的实现。调用泛型函数时，CLOS 的调度机制根据传入参数的实际类型动态选择最适用的方法：

```lisp
;; 定义泛型函数 add
(defgeneric add (a b))

;; 针对 number 类型定义加法
(defmethod add ((a number) (b number))
  (+ a b))

;; 针对向量与数字定义行为
(defmethod add ((a vector) (b number))
  (map 'vector (lambda (n) (+ n b)) a))

;; 针对字符串定义拼接
(defmethod add ((a string) (b string))
  (concatenate 'string a b))
```

调用示例：

```lisp
(add 2 3)            ; => 5
(add #(1 2 3) 5)     ; => #(6 7 8)
(add "HELLO " "LSP") ; => "HELLO LSP"
```

这里的 `add` 已不再是简单函数，而是一个泛型函数对象，抽象了行为并与方法集合关联，使行为选择延迟到运行时决策。

### 多方法（Multiple Dispatch）：从单分派到全局调度

CLOS 的一个核心特性就是**方法可根据多个参数的类型组合进行调度**。与传统 OOP 的单分派（只根据第一个接收者对象的类型确定方法）不同，CLOS 的调度算法会：

1. **收集所有适用的方法**：查找那些其参数类型限制都满足调用参数类型约束的实现；
2. **按具体性顺序排序**：更具体的类型组合优先级更高；
3. **方法组合（Method Combination）**：根据需要组合多个方法，形成一个“有效方法”；
4. **执行该有效方法**。

这种机制支持针对不同参数类型组合定义特化实现，并在运行时动态选择最合适的方法，是一种典型的迟绑定（Late Binding）策略。

> 当调用泛型函数时，只有在运行时才会根据参数的类型组合来确定具体要执行的代码分支。

与面向对象单分派不同，CLOS 的多方法不把“行为属于某个接收者对象”作为核心假设，而是把行为作为一个独立的函数集合看待，而后根据所有参与参数的类型来调度实现。这确认了以下几点：

* 方法与类没有固定的所有权关系；
* 泛型函数是行为的抽象；
* 方法选择是一个**运行时决策过程**。

### 方法组合（Method Combination）：不仅仅是选择一个方法

CLOS 进一步扩展了基本的多分派机制，引入 **方法组合策略**。方法组合允许对多个适用方法进行组合，而不是单纯选择一个：

* `:before` 方法可以在主方法之前运行；
* `:after` 方法可以在主方法之后运行；
* `:around` 可以控制主方法甚至替换它的执行。

这种组合策略扩展了泛型函数的表达力，使其不仅是方法选择器，更是一个具有完整行为组合语义的动态机制。

### Scheme 与 CLOS 的对比

在 Scheme 闭包对象模型中，方法封装在每个闭包内部，通过消息分发选择行为，行为附属于具体对象。

CLOS 则将行为抽象提升到语言级：方法属于泛型函数，通过全参数多分派和方法组合机制实现动态决策。这种设计支持更复杂的多态和抽象能力，同时保持动态灵活性。

## 性能的博弈（一）：单态化与“零成本抽象”

在前文中，我们已经详细讨论了 Scheme 的闭包机制以及 CLOS 的多方法模型。它们都代表了一类典型的动态语言设计：程序在运行时携带丰富的类型信息，通过消息分发或多方法选择，在执行过程中动态决定调用的具体实现。

这类设计的核心特征可以概括为一个关键词：**迟绑定（Late Binding）**。  
方法调用的目标并不会在编译期被固定下来，而是推迟到运行时，根据对象的实际类型再做决定。

迟绑定带来了极高的灵活性：程序员可以在并不知道未来会有哪些具体类型的前提下，编写高度通用的抽象代码。但它的代价同样明确——每一次调用都需要额外的调度过程，例如查表或间接跳转。

于是，一个关键问题自然浮现：

> 如果我们转向 Rust、C++ 这样的静态类型语言，是否还能在保留抽象能力的同时，获得接近手写代码的性能？

答案的关键不在于“是否支持多态”，而在于一个更基础的问题：**绑定时间（Binding Time）**。

### 绑定时间：决定“什么时候知道答案”

在静态类型语言中，多态并不是一个非黑即白的问题，而是一种时间上的选择：

> 我们打算在什么时候，确定方法调用的具体目标？

- 如果调用目标在**编译期**就已经确定，编译器就可以进行内联、展开与跨函数优化，生成高度专化的机器码；
- 如果必须等到**运行期**才能确定类型，那么就不可避免地需要借助查表或间接调用机制。

这并非纯粹的实现细节，而是语言设计与抽象机制所做出的根本性取舍。

在本章中，我们先站在性能这一侧，观察静态语言是如何系统性地将绑定时间尽可能提前的。它们最重要的手段，正是——**单态化（Monomorphization）**。

### 什么是单态化（Monomorphization）

单态化的本质，可以概括为一句话：

> 将泛型代码在编译期拆解为若干份针对具体类型的普通代码。

在这种策略下，运行时并不存在“泛型函数”或“多态调用”这一概念。所有调用目标都已经在编译阶段完全确定，这正是**早绑定（Early Binding / 静态分派）**的典型实现方式。

以 Rust 为例，考虑一个对任意可加类型进行运算的泛型函数：

```rust
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

fn main() {
    let x = add(1, 2);
    let y = add(1.5, 2.5);
}
```

在编译过程中，Rust 会分别为 `i32` 与 `f64` 生成两个具体化版本的函数，效果等价于手写的 `add_i32` 与 `add_f64`。调用时无需任何动态调度，性能与直接调用普通函数几乎一致。

C++ 的模板机制采用了同样的策略：

```cpp
template<typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    int x = add(1, 2);
    double y = add(1.5, 2.5);
}
```

编译器同样会为不同的类型实例生成独立的函数实现，运行时直接跳转，无需虚表或间接调用。可以看到，Rust 与 C++ 都通过单态化，将泛型抽象转化为编译期可完全解析的具体代码。

### 单态化的优势

单态化的优势直接源于其绑定时间策略——**在编译期就固定调用目标**：

- **零运行时开销**：方法选择在编译阶段完成，运行时不存在额外的调度成本。
- **更激进的优化空间**：静态分派允许编译器进行内联、常量传播、循环展开以及跨模块优化。
- **更强的类型安全**：所有类型约束与错误都能在编译期暴露，而非推迟到运行时。

正是由于这些特性，Rust 与 C++ 才能宣称其泛型机制实现了所谓的**“零成本抽象（Zero-Cost Abstraction）”**：抽象并未引入额外的运行时负担。

### 单态化的代价与权衡

单态化并非没有成本，其代价主要体现在编译阶段与产物规模上：

- **代码膨胀（Code Bloat）**：每种类型组合都会生成独立实现，可能显著增加二进制体积。
- **编译时间增长**：专化与优化多份代码会增加编译器负担，尤其在大型工程中尤为明显。
- **指令缓存压力**：更大的代码体积可能影响 I-Cache 命中率，对热路径性能产生负面影响。

因此，单态化体现的是一种典型的权衡：以更高的编译成本与代码体积，换取极低的运行时开销。

### 单态化的局限性：为何早绑定不能覆盖所有场景

单态化在静态语言中提供了一种在编译期就确定方法调用目标的策略，使得泛型代码执行效率极高，几乎不需要运行时调度开销。正是这种 早绑定（Early Binding / 静态分派） 策略，赋予了 Rust 和 C++ 等系统语言实现“零成本抽象”的能力：编译器在编译期间根据具体类型专化泛型函数，从而生成针对每种类型的高效实现版本。

然而，单态化能够成立的前提是：**所有可能的具体类型在编译期是已知且可枚举的**。一旦这一前提被打破，早绑定策略便难以继续适用。

一个典型的例子是**异构对象集合**：例如图形系统中的 `Shape` 容器，内部可能存放任意实现了某种接口的对象。这些具体类型往往无法在编译期穷举，甚至允许第三方扩展。在这种场景下，编译器不可能为所有潜在类型生成专化代码，单态化自然失效。

这种局限并非单纯的工程问题，而反映了类型系统的表达边界：当抽象的目标是**隐藏具体类型、延迟实现选择、允许开放式扩展**时，绑定时间就不可避免地被推迟到运行期。

这种局限不仅来源于编译器实现的工程约束，它还反映了类型系统在表达能力上的边界：当抽象要求隐藏具体类型、允许任意实现者扩展实现时，编译期就无法穷举类型组合，也就无法安全地进行早绑定。单态化虽然能提供极高的运行时性能，但在抽象表达力和类型未知时的灵活性方面本质上不够强大。因此，仅靠静态泛型机制无法满足所有语言抽象与程序设计的需求。


## 性能的博弈（二）：虚方法与动态派发

静态语言在提供单态化泛型的同时，也支持**运行时多态**（如 C++ 的虚函数、Rust 的 Trait 对象），这是一种 **动态派发（Dynamic Dispatch / 迟绑定）** 的实现方式。动态派发的核心是：**调用目标的绑定推迟到运行时**，根据值的实际类型选择方法实现。

在 Rust 中，Trait 对象（如 `&dyn Trait` 或 `Box<dyn Trait>`）内部包含数据指针和方法表（vtable）指针，调用时通过 vtable 确定实现；在 C++ 中，虚函数表（vtable）机制实现相同效果：基类指针或引用调用虚方法时，运行时读取对象的 vptr 并查表确定调用目标。

动态派发带来额外开销，但是单态化无法覆盖场景的唯一解决方案。当类型在编译期未知，或需要统一处理多种对象时，静态泛型无法工作，而动态派发允许在运行时操作那些只能在执行阶段确定类型的值。典型场景包括：

* **异构集合**：不同类型对象放入同一容器，并在运行时统一调用。
* **插件式架构 / ABI 扩展**：运行时加载新类型，编译期无法预知。

### 动态派发的本质：绑定推迟到运行时

动态派发的关键不在于“有无 vtable”，而是 **何时确定方法调用**。与单态化泛型不同，它在编译期放弃固定调用目标，而在**运行时**根据对象实际类型选择实现，这就是**迟绑定（Late Binding）**。

典型面向对象实现中（C++ 虚函数、Rust trait object）：

* 对象保存数据；
* 额外保存指向 **vtable** 的指针；
* 方法调用通过一次间接查表完成。

因此，**调用点在编译期无法确定具体实现**。

### 性能影响：可见性与优化边界的丧失

动态派发的开销不只是一次查表，而是**破坏了编译器对调用目标的可见性**。在早绑定下，编译器可以：

* 确定唯一调用目标；
* 内联函数；
* 进行跨函数优化、循环展开、常量传播。

而动态派发下：

* 调用目标在语义上开放；
* 编译器必须假设“可能是任何实现”；
* 多数激进优化被迫中止。

即使运行中调用几乎总是命中同一实现，这种“事实单态性”在 ABI 边界上不可见，除非启用 LTO 或 PGO 并证明去虚拟化安全，否则调用仍视为开放。

以 C++ 虚函数为例：

```cpp
struct Shape {
    virtual double area() const = 0;
};

struct Circle : Shape {
    double r;
    double area() const override {
        return 3.14159 * r * r;
    }
};

double compute(const Shape& s) {
    return s.area();
}

```

在 `compute` 中，`s.area()` 是一次典型的虚函数调用。对编译器而言：

* `s` 的静态类型是 `Shape&`，无法在编译期确定具体实现；
* `area` 的最终实现依赖对象携带的 vptr，在运行时通过 vtable 查表才能确定；
* 因此该调用通常无法内联，只能生成一次间接跳转。

即便在实际运行中，`compute` 几乎总是接收 `Circle` 实例，这种“事实上的单态性”在 ABI 边界上不可见。除非启用跨模块的 LTO 或基于运行分布的 PGO，并且编译器能够证明去虚拟化安全，否则该调用在语义上始终被视为“开放的”。

Rust 的 Trait 对象与 C++ 虚函数高度一致：

```rust
trait Shape {
    fn area(&self) -> f64;
}

struct Circle { r: f64 }

impl Shape for Circle {
    fn area(&self) -> f64 { 3.14159 * self.r * self.r }
}

fn compute(s: &dyn Shape) -> f64 {
    s.area()
}
```

这里的 `&dyn Shape` 在编译期被擦除为 *fat pointer*：包含数据指针和 vtable 指针。`s.area()` 调用同样通过 vtable 查找方法地址并进行间接调用，性能特征与 C++ 虚函数本质一致。

### 动态派发并非“慢”，而是“不可预测”

动态派发本身不必然慢：稳定间接跳转在现代处理器上只需几个周期，分支预测可能长期命中。问题在于**性能不可预测性**：

* 能否内联？——取决于去虚拟化；
* 间接跳转是否稳定？——取决于运行时类型分布；
* 缓存命中率如何？——取决于对象布局与访问模式。

相比之下，单态化泛型性能可预测：类型已知，调用几乎总被展开为直接调用，可享受完整优化。这种可预期性，是早绑定的重要价值。

### 动态派发的工程意义：表达能力优先于局部性能

动态派发的目的是解决单态化无法覆盖的场景，而不是提供同一问题的“低性能版本”。

典型例子：异构集合

```rust
trait Shape {
    fn area(&self) -> f64;
}

struct Circle { r: f64 }
struct Rectangle { w: f64, h: f64 }

impl Shape for Circle {
    fn area(&self) -> f64 { 3.14159 * self.r * self.r }
}

impl Shape for Rectangle {
    fn area(&self) -> f64 { self.w * self.h }
}

// 异构集合
let shapes: Vec<Box<dyn Shape>> = vec![
    Box::new(Circle { r: 1.0 }),
    Box::new(Rectangle { w: 2.0, h: 3.0 }),
    // 将来可能加入更多不同实现类型
];

let total: f64 = shapes.iter().map(|s| s.area()).sum();
```

这里关键不是 `area` 调用多了一次间接跳转，而是 集合中的元素类型在编译期不可枚举。单态化要求为每种类型生成专化代码，而开放类型集合无法在编译期穷举，因此单态化策略失效。

```cpp
struct Shape { virtual double area() const = 0; };
struct Circle : Shape { double r; double area() const override { return 3.14159 * r * r; } };
struct Rectangle : Shape { double w, h; double area() const override { return w * h; } };

std::vector<std::unique_ptr<Shape>> shapes;
shapes.push_back(std::make_unique<Circle>(1.0));
shapes.push_back(std::make_unique<Rectangle>(2.0, 3.0));
// 未来可能加入来自插件或动态库的其他 Shape 实现

double total = 0.0;
for (auto& s : shapes) total += s->area();

```

这里虚函数并非为了“省事”，而是表达 **运行时开放的类型集合**：这些类型可能来自不同模块、编译单元，甚至在程序运行时动态加载。对于这种抽象需求，迟绑定不是性能妥协，而是 语义前提，确保程序在类型未知或可扩展的情况下仍能正确工作。

在这种语境下，“能否内联”或“多一次跳转”是次要问题，关键是**抽象边界是否成立**。

接下来，我们将看到，现代语言通过类型系统和语法机制，让程序员**显式选择绑定时间**。Rust 与 C++ 就是两种典型实现。

## 现代语言的折衷：显式控制绑定时间

现代编程语言在抽象能力与性能之间提供了更细粒度、显式的控制手段。通过将泛型与动态多态都纳入语言核心，不同策略的**绑定时间（Binding Time）**成为语言设计者与程序员必须权衡的关键维度。典型代表是 **Rust** 和 **C++**，它们分别通过类型系统和语法机制提供了两条相辅相成的路径。

### Rust：静态泛型与动态 Trait 对象

Rust 在系统语言设计中有一个非常优雅的创新：它将静态分派（impl）与动态分派（dyn）统一在同一个 trait 系统下。这种设计让泛型与运行时多态成为同一抽象机制的两种绑定时间实现，而不再像 C++ 那样将模板和虚函数割裂开来。程序员可以通过简单的语法选择早绑定或迟绑定，而不需要在不同的语言机制间转换概念。

** 静态分派（Early Binding）**

在 Rust 中，默认情况下泛型函数使用 静态分派：编译器在编译期已知所有具体类型，并使用 单态化（monomorphization） 生成专用代码。这使得泛型函数在运行时没有额外分派开销。

```rust
fn process<T: Trait>(x: T) {
    x.some_method();
}

```

在此代码中，`T` 在编译期完全确定，因此 `some_method` 调用可被内联优化，无需运行时查表。静态分派正是 Rust 泛型性能可预测性的核心保证。

** 动态分派（Late Binding）**

Rust 也通过 Trait 对象（trait objects）支持 动态分派，即迟绑定：方法的具体实现推迟到运行时解析。Trait 对象通常使用 `&dyn Trait` 或 `Box<dyn Trait>` 语法，它们在内部为不同实现类型创建运行时 **虚方法表（vtable）**，调用时通过查表确定函数地址。

```rust
fn do_something(item: &dyn Trait) {
    item.method(); // 调用时查表
}

```

这种特性主要用于处理异构集合或运行时无法预知具体类型的情况，例如存储多个不同类型的 Trait 对象在同一向量中。其灵活性代价是运行时间接查表和无法内联优化。

Rust 的设计哲学在于：程序员在使用时显式声明绑定时间：

- 使用泛型（`fn <T: Trait>`） → 早绑定
- 使用 trait object（`dyn Trait`） → 迟绑定

因此，Rust 将绑定时间选择权交还给程序员：当需要运行时多态时使用 trait object；追求最大性能时使用静态泛型。

### C++ 的双轨体系

C++ 提供了两套机制：静态多态与运行时多态，它们各自强大且可组合使用。

** 静态多态（Early Binding）*

C++ 在静态多态表达上不仅支持类型模板参数，还支持任意满足约束的编译期常量作为非类型模板参数，例如整数、指针或枚举值等，这使得模板在表达静态泛型与编译期计算时具有更大的灵活性：

```cpp
template<typename T, int N>
void process(const T (&arr)[N]) {
    // N 是一个编译期常量，可参与代码生成
}

```

这种机制允许编译器在实例化时根据具体参数生成专用代码，使得 调用目标在编译期完全解析并固定，从而能够内联展开并进行跨模块优化，体现了早绑定的高性能特性。

在静态多态的基础上，C++ 模板还支持 模板特化（template specialization）——即为某些特定类型或组合提供“定制化”的实现。这一机制允许在编译期针对某些类型特征选择更合适的实现版本，是 **特设多态（Ad hoc Polymorphism）** 的一种典型形式，因为它并不是泛型一致行为的展开，而是为特定类型组合提供专门实现。

不过由于 C++ 模板本身对参数的约束是“只要能使模板体内的表达式在实例化时合法就行”，这是一种较宽松的静态多态形式。为了在类型约束上提供更清晰、更可控的接口检查，C++20 引入了 Concepts——一种在编译期对模板参数施加约束的机制，它以命名的布尔谓词定义类型要满足的特定语义。

```cpp
template<typename T>
requires requires(T t) { t.method(); }
void process_safe(T x) {
    x.method(); // 编译期检查 T 是否满足约束
}

```

在静态多态范式中，C++ 的 Curiously Recurring Template Pattern（CRTP） 是一种常见的技巧，它利用模板将派生类自身作为基类模板的参数，从而让基类模板在编译期知道派生类的具体类型，并在内部通过静态转换调用派生类实现，实现**编译时多态（static polymorphism）**而无需虚函数开销。

```cpp
template <typename Derived>
class Base {
public:
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
};

class Derived : public Base<Derived> {
public:
    void implementation() { /* 子类逻辑 */ }
};

```

在这种模式下，`Base<Derived>::interface` 在编译期就能确定 `Derived` 的具体实现，避免了运行时的间接跳转调用。

值得注意的是，C++23 引入的 `deducing this` 特性可以进一步简化这类静态多态表达，使得模板函数能够根据调用对象的静态类型推导出 this 参数，而无需在基类模板中显式传递派生类型，从而在某些场景下使 CRTP 的模板负担减轻。

** 动态分派（Late Binding）**

C++ 通过 虚函数实现 迟绑定：函数调用在运行时基于对象实际类型解析。使用 virtual 声明的成员函数在调用时查 vtable 决定调用目标。

```cpp
class Base {
public:
    virtual void greet() = 0; // 纯虚函数
};

class Derived : public Base {
public:
    void greet() override { /* 实现 */ }
};

```

动态派发让不同子类型可在同一接口下运行，但不可避免会产生运行时查表和间接跳转开销，相比静态调用，目标函数只有在运行时才能确定。

### 显式控制绑定时间的价值

现代语言提供显式控制绑定时间的机制，其核心目标是让程序员根据具体场景选择合适的抽象与效率折中：

- 性能优先时 → 静态分派（早绑定）
  将所有类型决策推到编译期，消除运行时开销，使调用可内联，执行高效可预测。
- 灵活性优先时 → 动态分派（迟绑定）
  调用目标在运行时确定，允许异构集合、插件式架构、运行时动态类型，牺牲部分优化潜力换取设计灵活性。
  
程序员必须在这两种机制间权衡，这正是系统架构设计的核心考量。

### 绑定时间对比

| 语言机制                 | 多态类别  | 绑定时间     | 行为特性                      |
| -------------------- | ----- | -------- | ------------------------- |
| Rust 泛型（静态 dispatch） | 参数多态  | 编译期（早绑定） | 针对具体类型生成专用代码，可内联优化        |
| Rust Trait 对象 (dyn)  | 运行时多态 | 运行时（迟绑定） | 支持异构集合，调用需查表，无法内联         |
| C++ 模板               | 参数多态  | 编译期（早绑定） | 每种类型生成独立函数版本，优化空间充足       |
| C++ 虚函数              | 子类型多态 | 运行时（迟绑定） | 调用通过 vtable 查表决定，支持开放类型集合 |

这种显式分离多态与绑定时间的设计，使语言的抽象能力与性能折中更加透明，程序员可明确表达性能意图。通过这一机制，现代语言不仅为性能优化提供了工具，也为架构设计提供了清晰原则：何时做出类型或方法调用决策，即绑定时间的选择，是多态设计的核心。

## 多态的分类

在编程语言理论和类型系统研究中，多态（polymorphism）是指同一形式的代码可以作用于多种类型的值这一能力。根据其语义基础和实现机制的不同，多态通常被划分为三类基本形态：

- 参数多态（Parametric Polymorphism）
- 特设多态（Ad hoc Polymorphism）
- 子类型多态（Subtype Polymorphism）

### 参数多态（Parametric Polymorphism）

参数多态允许一段代码对不同类型采取统一的行为描述，这种行为与具体类型无关，而是通过类型参数进行抽象。典型例子是泛型函数或模板定义，其定义不包含具体类型，但在实例化时可以应用于任意满足约束的类型。

参数多态具有一个关键性质：

> 对于不同类型的操作行为是统一的——逻辑行为不依赖类型本身。

这一性质使其成为泛型编程的基础，如函数处理各种容器类型或通用算法处理不同元素类型。

在实现上，这类多态通常采用 早绑定（Early Binding）：编译器在编译期根据参数类型生成特定版本的代码（单态化），从而避免运行时分派开销。

代表机制： C++ 模板、Rust 泛型、ML/Haskell 的类型参数机制。

**示例：C++ 模板**

```cpp
template <typename T>
T max_value(T a, T b) {
    return a > b ? a : b;
}

int i = max_value(10, 20);        // 生成 max_value<int>
double d = max_value(1.5, 2.5);   // 生成 max_value<double>

```

模板在编译期展开为具体类型版本，调用目标在编译期确定。

**示例：Rust 泛型**

```rust
fn max_val<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}
let x = max_val(3, 7); // 编译期生成 i32 版本

```

Rust 的泛型单态化同样在编译期将泛型函数展开为特定类型代码，避免运行期开销。

### 特设多态（Ad hoc Polymorphism）

特设多态描述的是这样一种情况：同一个名字或接口在不同类型上的行为可能不同，而这些不同的实现是针对特定类型定义的。换言之，它不是单一通用行为，而是对不同类型提供各自实现。这一术语最早由 Christopher Strachey 提出，用于区别泛型行为和 ad hoc（特设）行为。

特设多态的典型例子包括：

- 函数重载（同名但参数不同的函数定义）
- 运算符重载
- 模板特化（为特定类型或组合提供专门实现）

在这些场景中，编译器在编译期选择最适合的实现版本，因此特设多态仍然主要伴随**早绑定机制**。

**C++ 函数重载示例**

```cpp
int add(int a, int b) { return a + b; }
std::string add(const std::string &a, const std::string &b) { return a + b; }

```

调用 add 时，编译器根据参数类型静态决定具体重载版本。

> 注意：在 C++ 中，模板特化、函数重载与运算符重载均属于特设多态的一种实现形式。

**模板特化示例**

```cpp
// 通用（primary）模板
template <typename T, int N>
class Value {
public:
    void print() const {
        std::cout << "Primary template: T, N = " << N << "\n";
    }
};

// 全特化：当 T = double 且 N = 5 时
template <>
class Value<double, 5> {
public:
    void print() const {
        std::cout << "Full specialization: double, 5\n";
    }
};

// 偏特化：当第一个模板参数是指针类型时
template <typename U, int N>
class Value<U*, N> {
public:
    void print() const {
        std::cout << "Partial specialization: pointer type, N = " << N << "\n";
    }
};

int main() {
    Value<int, 10> v1;      // 使用 primary template
    Value<double, 5> v2;    // 使用全特化
    Value<char*, 3> v3;     // 使用偏特化

    v1.print();
    v2.print();
    v3.print();
}

```

这种机制让语言在静态多态基础上进一步支持 基于类型模式的定制行为，它不是统一泛型行为的一个实例，而是针对特定类型/模式的多实现集合，因此属于 特设多态 的一种表现形式。

在编译期完成选择，因此模板特化、函数重载等机制与其它早绑定技术一样，并不会引入运行时查表或间接跳转的分派开销。

### 子类型多态（Subtype Polymorphism）

子类型多态是面向对象语言中最常见的多态形式之一。它允许一个泛化类型（如父类或接口）引用不同子类型实例，并在方法调用时根据对象的实际运行时类型选择对应实现。

- 在 C++、Java 等语言中通过 虚函数 / 接口方法 实现动态派发
- 在函数式语言的某些扩展（如 CLOS）中通过多方法实现更复杂的运行时调度

这种多态典型机制涉及 迟绑定（Late Binding）：方法的具体实现直到程序运行时才根据对象实际类型动态决定。适用于处理异构对象集合和动态行为扩展。

**示例：C++**

```cpp
struct Animal { virtual void speak(); };
struct Dog : Animal { void speak() override { /* ... */ } };

Animal *a = new Dog;
a->speak(); // 运行时根据实际类型调用 Dog::speak

```

虚函数调用通过虚表（vtable）在运行时查找实际实现。

**示例：Java**

```java
interface Shape { void draw(); }
class Circle implements Shape { public void draw() { } }

Shape s = new Circle();
s.draw(); // JVM 运行时调度 Circle::draw

```

Java 动态 dispatch 机制在运行期根据对象类型决定方法实现。

### 多态分类与绑定时间对照表

下面的表格展示了三类多态机制与其典型实现的绑定时间关系：

| 多态类型             | 核心机制           | 绑定时间        | 示例                |
| ---------------- | -------------- | ----------- | ----------------- |
| 参数多态（Parametric） | 泛型 / 模板 / 类型变量 | **早绑定**     | Rust 泛型、C++ 模板    |
| 特设多态（Ad hoc）     | 重载 / 模板特化      | **早绑定（主要）** | C++ 函数重载、模板特化     |
| 子类型多态（Subtype）   | 虚函数 / 接口实现     | **迟绑定**     | C++ 虚函数、Java 方法重写 |

### 理论与实践的联系

在语言设计理论中，参数多态与特设多态最早由 Strachey 在类型系统研究中提出，并被用于区分泛型行为与类型特定行为的语义差异；而子类型多态则源于面向对象系统对继承与接口的支持，它是运行时类型层次和动态 dispatch 的直接产物。

值得注意的是，在高级类型系统中，这三者之间的界限有时会交叉演化。例如，在 Haskell 的类型类（type class）中，某些形式的多态既具有参数泛化特征，又依赖具体类型实例实现，在表达能力上超越传统静态类型分类。

### 多态的分类与绑定时间

通过对参数多态、特设多态与子类型多态的分析，我们可以看到：

- 参数多态强调统一行为与高复用性，通常采用早绑定以获得性能优势；
- 特设多态强调对不同类型的定制实现，通常在编译期静态选择对应版本；
- 子类型多态强调根据对象实际类型运行时决策，是典型的迟绑定机制。

这些多态机制既体现了语言对抽象灵活性的支持，也代表了不同的性能折中策略：在需求侧从类型安全与复用性出发，在实现侧从绑定时间与执行成本权衡。

## 小结：多态的全景

最早在 Scheme 中，我们用闭包和消息传递看到：同一个消息名称发送给不同对象时，每个对象会根据自己的内部实现做出不同响应，这正是最直观的多态——同一调用，不同回应。正如面向对象的基本定义里提到的，不同对象收到同一消息会产生不同结果，这本质就是多态。

CLOS 在这个基础上进一步提升，它把方法和行为抽象成真正独立的“泛型函数”，然后让运行时根据所有参数的类型组合来选择最具体的实现。这种多分派机制不再局限于“对象自身的单个类型”，而是在运行时根据整个调用上下文来决定行为，这是运行时抽象的一种更强形式。

静态语言则通过不同策略对这一问题做出自己的折中。Rust 和 C++ 在需要效率时尽可能把调用目标在编译期就固定下来，这样就能在运行时直接执行特化的代码版本；而在需要灵活时，它们也提供虚表等机制以便在运行时再根据对象的真实类型做出选择。它们不是在逃避多态，而是在让“何时做出决定”这一问题变得显式可控。

归根结底，多态并不是某种单一的语言特性，而是一套处理“变动”的策略。虽然从动态闭包到静态模板的实现手段千差万别，但核心都在于解答同一个工程问题：我们要把“确定行为”这个动作放在什么时候去做？ 只有理清了这些机制背后的绑定逻辑，我们才能在面对复杂的业务场景时，不再纠结于语法表象，而是能根据对性能和灵活性的真实需求，做出最合理的工程取舍。
